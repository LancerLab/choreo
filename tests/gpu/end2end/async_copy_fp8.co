// REQUIRES: TARGET-SM_90
// RUN: choreo -gs -t cute -arch=sm_90a %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck %s && rm -f %s.cute.result

__co__ auto dma_copy(f8_e5m2 [M, 17, 32] input) {
  f8_e5m2 [input.span] output;

  parallel by 1 : group {
    f = dma.copy.async input => shared;
    wait f;
    dma.copy f.data => output;
  }

  return output;
}

__co__ auto dma_add(f8_e5m2 [M, 17, 32] in0, f8_e5m2 [6, N, 32] in1) {
  f16 [in0.span] output;

  parallel q0 by in1.span(1) : group {
    f0 = dma.copy.async in0 => shared;
    f1 = dma.copy.async in1 => shared;
    wait f0, f1;
    shared f16 [f0.span] out;
    foreach x in [in1.span(0)]
      parallel {q1} by [in1.span(2)]
        out.at(x, q0, q1) = f0.data.at(x, q0, q1) + f1.data.at(x, q0, q1);
    dma.copy out => output;
  }

  return output;
}

__co__ auto dma_add1(f8_e5m2 [M, 17, 32] in0, f8_e5m2 [6, N, 32] in1) {
  f16 [in0.span] output;

  parallel q0 by in1.span(1) : group {
    f0 = dma.copy.async in0 => shared;
    f1 = dma.copy.async in1 => shared;
    wait f1, f0;
    shared f16 [f0.span] out;
    foreach x in [in1.span(0)]
      parallel {q1} by [in1.span(2)]
        out.at(x, q0, q1) = f0.data.at(x, q0, q1) + f1.data.at(x, q0, q1);
    dma.copy out => output;
  }

  return output;
}

int main() {
  auto a = choreo::make_spandata<choreo::f8_e5m2>(6, 17, 32);
  auto b = choreo::make_spandata<choreo::f8_e5m2>(6, 17, 32);
  a.fill_random(-2.0f, 2.0f);
  b.fill_random(-2.0f, 2.0f);

  auto res = dma_copy(a.view());

  for (size_t i = 0; i < res.shape()[0]; ++i)
    for (size_t j = 0; j < res.shape()[1]; ++j)
      for (size_t k = 0; k < res.shape()[2]; ++k)
        choreo::choreo_assert(float(a[i][j][k]) == float(res[i][j][k]), "values are not equal.");

  std::cout << "Test 0 Passed\n" << std::endl;

  auto sum = dma_add(a.view(), b.view());

  float tolerance = 0.35f;
  for (size_t i = 0; i < sum.shape()[0]; ++i)
    for (size_t j = 0; j < sum.shape()[1]; ++j)
      for (size_t k = 0; k < sum.shape()[2]; ++k) {
        float ref = float(a[i][j][k]) + float(b[i][j][k]);
        float got = float(sum[i][j][k]);
        choreo::choreo_assert(std::abs(got - ref) <= tolerance, "values are not equal.");
      }

  std::cout << "Test 1 Passed\n" << std::endl;

  auto sum1 = dma_add1(a.view(), b.view());

  for (size_t i = 0; i < sum1.shape()[0]; ++i)
    for (size_t j = 0; j < sum1.shape()[1]; ++j)
      for (size_t k = 0; k < sum1.shape()[2]; ++k) {
        float ref = float(a[i][j][k]) + float(b[i][j][k]);
        float got = float(sum1[i][j][k]);
        choreo::choreo_assert(std::abs(got - ref) <= tolerance, "values are not equal.");
      }

  std::cout << "Test 2 Passed\n" << std::endl;
}

// CHECK-NOT: choreo-rt
// CHECK: Test 0 Passed
// CHECK-NOT: choreo-rt
// CHECK: Test 1 Passed
// CHECK-NOT: choreo-rt
// CHECK: Test 2 Passed
