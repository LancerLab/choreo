// REQUIRES: TARGET-GPU
// RUN: choreo -gs -t cute %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

#define M 256 
#define N 256 
#define K 256 

__co__ auto matmul(f16 [M, K] lhs, f16 [K, N] rhs) {
  f16 [M, N] output{0.0f};

  int TILE_M = 32, TILE_N = 32, TILE_K = 16;
  int WARP_M = 8, WARP_N = 8, WARP_K = 4;
  // int WARP_M = 16, WARP_N = 16, WARP_K = 16;

  // each block handles 128x128 block
  parallel {block_m, block_n} by [cdiv(M, TILE_M), cdiv(N, TILE_N)] : block {
    foreach {iv_k} in [cdiv(K, TILE_K)] {
      lhs_load_s = dma.copy lhs.chunkat(block_m, iv_k) => shared;
      rhs_load_s = dma.copy rhs.chunkat(iv_k, block_n) => shared;

      parallel {iv_warp_m, iv_warp_n} by [cdiv(TILE_M, WARP_M), cdiv(TILE_N, WARP_N)] : group {
        
        mc = mma.load output.chunkat(block_m#iv_warp_m, block_n#iv_warp_n);
        foreach iv_warp_k in [cdiv(TILE_K, WARP_K)] {
          ma = mma.load lhs_load_s.chunkat(iv_warp_m, iv_warp_k);
          mb = mma.load rhs_load_s.chunkat(iv_warp_k, iv_warp_n);
          mma.row.col mc, ma, mb;
        }
        mma.store mc, output.chunkat(block_m#iv_warp_m, block_n#iv_warp_n);
      }
    }
  }

  return output;
}

int main() {
  auto lhs = choreo::make_spandata<choreo::f16>(M, K);
  auto rhs = choreo::make_spandata<choreo::f16>(K, N);
#if 1
  for (size_t i = 0; i < lhs.shape()[0]; ++i)
    for (size_t j = 0; j < lhs.shape()[1]; ++j) {
      lhs[i][j] = __float2half(i*0.02f+j*0.01f);
    }
  for (size_t i = 0; i < rhs.shape()[0]; ++i)
    for (size_t j = 0; j < rhs.shape()[1]; ++j) {
      rhs[i][j] = __float2half(i*0.07f+j*0.03f);
    }
#else
  lhs.fill_random(0.0, 0.05);
  rhs.fill_random(0.0, 0.05);
#endif

  auto res = matmul(lhs.view(), rhs.view());

  float tolerance = 0.007f;
  // verfication
  for (size_t i = 0; i < res.shape()[0]; ++i)
    for (size_t j = 0; j < res.shape()[1]; ++j) {
      __half ref = __float2half(0.0f);
      for (size_t k = 0; k < lhs.shape()[1]; ++k)
        ref += lhs[i][k] * rhs[k][j];
      auto delta = std::abs((__half2float(ref) - __half2float(res[i][j])) / __half2float(ref));
      if (delta >= tolerance) {
        std::cout << "[" << i << ", " << j << "] " << __half2float(ref) << " <-> " << __half2float(res[i][j]) << ", delta: " << delta * 100 << "%\n";
      }
      choreo::choreo_assert((delta < tolerance), "values are not equal.");
    }

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed
