// REQUIRES: TARGET-GPU
// RUN: choreo -gs -t cute %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

#define M 64
#define N 64
#define K 32

__co__ auto matmul(f16 [M, K] lhs, f16 [K, N] rhs) {
  f16 [M, N] output;

  int MMA_M = 16, MMA_N = 16, MMA_K = 16;

  parallel {m, n} by [M / MMA_M / 4, N / MMA_N ] : block {
    parallel {g0, g1} by [4, 1]: group {
      mc = mma.fill 0.0;  // c = {0}
      with k in K / MMA_K {
        fl0 = dma.copy.async lhs => shared;
        fr0 = dma.copy.async rhs => shared;
        fl1 = dma.any;
        fr1 = dma.any;
        foreach k(1:) {
          fl1 = dma.copy.async lhs => shared;
          fr1 = dma.copy.async rhs => shared;

          wait fl0, fr0;
          ma = mma.load fl0.chunkat(m#g0, k - 1);
          mb = mma.load fr0.chunkat(k - 1, n#g1);
          mma.row.col mc, ma, mb;   // row * col : c += a * b;

          swap(fl0, fl1);
          swap(fr0, fr1);
        }

        wait fl0, fr0;
        ma = mma.load fl0.chunkat(m#g0, k(-1));
        mb = mma.load fr0.chunkat(k(-1), n#g1);
        mma.row.col mc, ma, mb;   // row * col : c += a * b;
      }
      mma.store mc, output.chunkat(m#g0, n#g1);
    }
  }

  return output;
}

int main() {
  auto lhs = choreo::make_spandata<choreo::f16>(M, K);
  auto rhs = choreo::make_spandata<choreo::f16>(K, N);
  lhs.fill_random(1, 10);
  rhs.fill_random(1, 10);

  auto res = matmul(lhs.view(), rhs.view());

  float base_tol = 0.001f;
  float rel_tol = 0.002f;
  // verification (subset)
  choreo::verify_matmul_row_col_subset(lhs, rhs, res, base_tol, rel_tol, 8, 8);

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed
