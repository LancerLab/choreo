// REQUIRES: TARGET-GPU
// RUN: choreo -gs -t cute %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

__co__ s32 [128, 256] matmul(s32 [128, 256] lhs, s32 [256, 256] rhs) {
  s32[lhs.span(0), rhs.span(1)] output;
  parallel {px, py} by [8, 16] {
    foreach {tile_k} in [16] {
      lhs_load = dma.copy lhs.chunkat(px, tile_k) => local;
      rhs_load = dma.copy rhs.chunkat(tile_k , py) => local;
      parallel {qx, qy} by [16, 16] {
        foreach k in [256 / #tile_k] {
          output.at(px#qx, py#qy) += lhs_load.data.at(qx, k) * rhs_load.data.at(k, qy);
        }
      }
    }
  }

  return output;
}

int main() { /// host program
  choreo::s32 a[128][256] = {0};
  choreo::s32 b[256][256] = {0};
  auto lhs_data = choreo::make_spanview<2, choreo::s32>((int*)a, {128, 256});
  auto rhs_data = choreo::make_spanview<2, choreo::s32>((int*)b, {256, 256});
  lhs_data.fill_random(-10, 10);
  rhs_data.fill_random(-10, 10);

  auto res = matmul(lhs_data, rhs_data);

  // verfication
  for (size_t i = 0; i < res.shape()[0]; ++i)
    for (size_t j = 0; j < res.shape()[1]; ++j) {
      int ref = 0;
      for (size_t k = 0; k < lhs_data.shape()[1]; ++k)
        ref += a[i][k]*b[k][j];
      // std::cout << "res[" << i << "][" << j << "] = " << res[i][j] << ", ref = " << ref << std::endl;
      choreo::choreo_assert(ref == res[i][j], "values are not equal.");
    }

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed

