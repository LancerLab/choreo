// REQUIRES: TARGET-SM_90
// RUN: choreo -gs -t cute -arch=sm_90 %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

#define M 64
#define N 32
#define K 32

__co__ auto matmul_e4m3(f8_e4m3 [M, K] lhs, f8_e4m3 [K, N] rhs) {
  f32 [M, N] output;

  int MMA_M = 16, MMA_N = 8, MMA_K = 32;

  parallel {m, n} by [M / MMA_M / 4, N / MMA_N ] : block {
    parallel {g0, g1} by [4, 1]: group {
      mc = mma.fill.f32 0.0;  // c = {0}
      with k in K / MMA_K {
        fl0 = dma.copy.async lhs => shared;
        fr0 = dma.copy.async rhs => shared;
        fl1 = dma.any;
        fr1 = dma.any;
        foreach k(1:) {
          fl1 = dma.copy.async lhs => shared;
          fr1 = dma.copy.async rhs => shared;

          wait fl0, fr0;
          ma = mma.load fl0.chunkat(m#g0, k - 1);
          mb = mma.load fr0.chunkat(k - 1, n#g1);
          mma.row.col mc, ma, mb;   // row * col : c += a * b;

          swap(fl0, fl1);
          swap(fr0, fr1);
        }

        wait fl0, fr0;
        ma = mma.load fl0.chunkat(m#g0, k(-1));
        mb = mma.load fr0.chunkat(k(-1), n#g1);
        mma.row.col mc, ma, mb;   // row * col : c += a * b;
      }
      mma.store mc, output.chunkat(m#g0, n#g1);
    }
  }

  return output;
}

__co__ auto matmul_e5m2(f8_e5m2 [M, K] lhs, f8_e5m2 [K, N] rhs) {
  f32 [M, N] output;

  int MMA_M = 16, MMA_N = 8, MMA_K = 32;

  parallel {m, n} by [M / MMA_M / 4, N / MMA_N ] : block {
    parallel {g0, g1} by [4, 1]: group {
      mc = mma.fill.f32 0.0;  // c = {0}
      with k in K / MMA_K {
        fl0 = dma.copy.async lhs => shared;
        fr0 = dma.copy.async rhs => shared;
        fl1 = dma.any;
        fr1 = dma.any;
        foreach k(1:) {
          fl1 = dma.copy.async lhs => shared;
          fr1 = dma.copy.async rhs => shared;

          wait fl0, fr0;
          ma = mma.load fl0.chunkat(m#g0, k - 1);
          mb = mma.load fr0.chunkat(k - 1, n#g1);
          mma.row.col mc, ma, mb;   // row * col : c += a * b;

          swap(fl0, fl1);
          swap(fr0, fr1);
        }

        wait fl0, fr0;
        ma = mma.load fl0.chunkat(m#g0, k(-1));
        mb = mma.load fr0.chunkat(k(-1), n#g1);
        mma.row.col mc, ma, mb;   // row * col : c += a * b;
      }
      mma.store mc, output.chunkat(m#g0, n#g1);
    }
  }

  return output;
}

int main() {
  auto lhs_e4m3 = choreo::make_spandata<choreo::f8_e4m3>(M, K);
  auto rhs_e4m3 = choreo::make_spandata<choreo::f8_e4m3>(K, N);
  lhs_e4m3.fill_random(-2.0f, 2.0f);
  rhs_e4m3.fill_random(-2.0f, 2.0f);

  auto res_e4m3 = matmul_e4m3(lhs_e4m3.view(), rhs_e4m3.view());

  float base_tol = 0.2f;
  float rel_tol = 0.02f;
  choreo::verify_matmul_row_col_subset(lhs_e4m3, rhs_e4m3, res_e4m3, base_tol,
                                       rel_tol, 8, 8);

  std::cout << "Test E4M3 Passed\n" << std::endl;

  auto lhs_e5m2 = choreo::make_spandata<choreo::f8_e5m2>(M, K);
  auto rhs_e5m2 = choreo::make_spandata<choreo::f8_e5m2>(K, N);
  lhs_e5m2.fill_random(-2.0f, 2.0f);
  rhs_e5m2.fill_random(-2.0f, 2.0f);

  auto res_e5m2 = matmul_e5m2(lhs_e5m2.view(), rhs_e5m2.view());

  choreo::verify_matmul_row_col_subset(lhs_e5m2, rhs_e5m2, res_e5m2, base_tol,
                                       rel_tol, 8, 8);

  std::cout << "Test E5M2 Passed\n" << std::endl;
}

// CHECK: Test E4M3 Passed
// CHECK: Test E5M2 Passed
