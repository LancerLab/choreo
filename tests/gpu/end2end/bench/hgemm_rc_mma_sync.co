// REQUIRES: TARGET-GPU
// RUN: choreo -gs -t cute -arch=sm_86 %s -o %s.cute.result && CHOREO_DISABLE_TIMING=1 bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

#define M 256
#define N 256
#define K 256

__co__ auto matmul(f16 [M, K] lhs, f16 [N, K] rhs) {
  f16 [M, N] output{0.0f};

  int TILE_M = 32, TILE_N = 32, TILE_K = 16;
  int WARP_M = 16, WARP_N = 16, WARP_K = 16;

  parallel {block_m, block_n} by [cdiv(M, TILE_M), cdiv(N, TILE_N)] : block {
    parallel {iv_warp_m, iv_warp_n} by [cdiv(TILE_M, WARP_M), cdiv(TILE_N, WARP_N)] : group {
      mc = mma.fill 0.0;
      foreach {iv_k} in [cdiv(K, TILE_K)] {

        lhs_load_s = dma.copy lhs.chunkat(block_m, iv_k) => shared;
        rhs_load_s = dma.copy rhs.chunkat(block_n, iv_k) => shared;

        foreach iv_warp_k in [cdiv(TILE_K, WARP_K)] {
          ma = mma.load lhs_load_s.chunkat(iv_warp_m, iv_warp_k);
          mb = mma.load rhs_load_s.chunkat(iv_warp_n, iv_warp_k);
          mma.row.row mc, ma, mb;   // row * col : c += a * b;
        }
      }
      mma.store mc, output.chunkat(block_m#iv_warp_m, block_n#iv_warp_n);
    }
  }

  return output;
}

int main(int argc, char** argv) {
  bool enable_timing = true;
  auto is_disable_timing_arg = [](const char* s) {
    const char* t = "--disable-timing";
    int i = 0;
    while (t[i] != '\0' && s[i] == t[i]) ++i;
    return t[i] == '\0' && s[i] == '\0';
  };
  for (int i = 1; i < argc; ++i) {
    if (is_disable_timing_arg(argv[i])) {
      enable_timing = false;
      break;
    }
  }

  const char* timing_env = std::getenv("CHOREO_DISABLE_TIMING");
  if (timing_env && timing_env[0] == '1' && timing_env[1] == '\0') {
    enable_timing = false;
  }

  auto lhs = choreo::make_spandata<choreo::f16>(M, K);
  auto rhs = choreo::make_spandata<choreo::f16>(N, K);
  lhs.fill_random(1.0, 10.0);
  rhs.fill_random(1.0, 10.0);

  auto res = matmul(lhs.view(), rhs.view());

  if (enable_timing) {
    choreo::TimerOption topt;
      topt.warmup = 10;
      topt.repeat = 50;
      auto avg_ms = choreo::timing(
          [&]() {
            auto tmp = matmul(lhs.view(), rhs.view());
            (void)tmp;
          },
          topt);
      std::cout << "Timing avg ms: " << avg_ms << "\n";
  }

  // choreo::ProfilerOption popt;
  // popt.warmup = 5;
  // popt.repeat = 10;
  // popt.kernel_name = "hgemm_rc_mma_sync";
  // popt.ncu_args = "--target-processes all";
  // bool prof_ok = choreo::profile(
  //     [&]() {
  //       auto tmp = matmul(lhs.view(), rhs.view());
  //       (void)tmp;
  //     },
  //     popt);
  // std::cout << "Profile: " << (prof_ok ? "OK" : "FAILED") << "\n";
  // std::cout << "NCU path: " << popt.ncu_path << "\n";
  // std::cout << "NCU output: " << popt.ncu_output << "\n";

  float tolerance = 0.005f;
  // verfication
  for (size_t i = 0; i < res.shape()[0]; ++i)
    for (size_t j = 0; j < res.shape()[1]; ++j) {
      auto ref = 0.0f;
      for (size_t k = 0; k < lhs.shape()[1]; ++k)
        ref += __half2float(lhs[i][k] * rhs[j][k]);
      auto delta = std::abs((ref - __half2float(res[i][j])) / ref);
      if (delta >= tolerance) {
        std::cout << "[" << i << ", " << j << "] " << ref << " <-> " << __half2float(res[i][j]) << ", delta: " << delta * 100 << "%\n";
      }
      choreo::choreo_assert((delta < tolerance), "values are not equal.");
    }

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed
