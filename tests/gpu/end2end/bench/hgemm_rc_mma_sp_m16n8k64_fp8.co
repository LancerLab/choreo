// REQUIRES: TARGET-SM_90
// RUN: choreo -gs -t cute -arch=sm_90 %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

#define M 256
#define N 256
#define K 256
#define META_K 64

// Sparse GEMM: A is 2:4 structured sparse (pre-packed), B is dense
// K-major operands for row.row MMA with FP8 types

__co__ auto matmul_sp_k64_e4m3(f8_e4m3 [M, K/2] lhs_packed, u32 [M, (K / META_K) * 2] lhs_meta, f8_e4m3 [N, K] rhs) {
  f32 [M, N] output{0.0f};
  int TILE_M = 64, TILE_N = 64, TILE_K = 64;
  int WARP_M = 16, WARP_N = 8, WARP_K = 64;
  parallel {block_m, block_n} by [cdiv(M, TILE_M), cdiv(N, TILE_N)] : block {
    parallel {iv_warp_m, iv_warp_n} by [cdiv(TILE_M, WARP_M), cdiv(TILE_N, WARP_N)] : group {
      mc = mma.fill.f32 0.0f;
      foreach {iv_k} in [cdiv(K, TILE_K)] {
        lhs_load_s = dma.copy lhs_packed.chunkat(block_m, iv_k) => shared;
        rhs_load_s = dma.copy rhs.chunkat(block_n, iv_k) => shared;
        lhs_load_s_mdata = dma.copy lhs_meta.chunkat(block_m, iv_k) => local;
        foreach iv_warp_k in [cdiv(TILE_K, WARP_K)] {
          ma = mma.load lhs_load_s.chunkat(iv_warp_m, iv_warp_k);
          mb = mma.load rhs_load_s.chunkat(iv_warp_n, iv_warp_k);
          me = mma.load lhs_load_s_mdata.chunkat(iv_warp_m, iv_warp_k);
          mma.row.row.sp mc, ma, mb, me;
        }
      }
      mma.store mc, output.chunkat(block_m#iv_warp_m, block_n#iv_warp_n);
    }
  }
  return output;
}

template <typename T>
using SparsePolicy = choreo::utils::SparsePolicy<T>;

// e5m2 + mixed kernels (kept next to e4m3 for parity testing)
__co__ auto matmul_sp_k64_e5m2(f8_e5m2 [M, K/2] lhs_packed, u32 [M, (K / META_K) * 2] lhs_meta, f8_e5m2 [N, K] rhs) {
  f32 [M, N] output{0.0f};
  int TILE_M = 64, TILE_N = 64, TILE_K = 64;
  int WARP_M = 16, WARP_N = 8, WARP_K = 64;
  parallel {block_m, block_n} by [cdiv(M, TILE_M), cdiv(N, TILE_N)] : block {
    parallel {iv_warp_m, iv_warp_n} by [cdiv(TILE_M, WARP_M), cdiv(TILE_N, WARP_N)] : group {
      mc = mma.fill.f32 0.0f;
      foreach {iv_k} in [cdiv(K, TILE_K)] {
        lhs_load_s = dma.copy lhs_packed.chunkat(block_m, iv_k) => shared;
        rhs_load_s = dma.copy rhs.chunkat(block_n, iv_k) => shared;
        lhs_load_s_mdata = dma.copy lhs_meta.chunkat(block_m, iv_k) => local;
        foreach iv_warp_k in [cdiv(TILE_K, WARP_K)] {
          ma = mma.load lhs_load_s.chunkat(iv_warp_m, iv_warp_k);
          mb = mma.load rhs_load_s.chunkat(iv_warp_n, iv_warp_k);
          me = mma.load lhs_load_s_mdata.chunkat(iv_warp_m, iv_warp_k);
          mma.row.row.sp mc, ma, mb, me;
        }
      }
      mma.store mc, output.chunkat(block_m#iv_warp_m, block_n#iv_warp_n);
    }
  }
  return output;
}

// mixed A:e4m3, B:e5m2
__co__ auto matmul_sp_k64_e4m3_e5m2(f8_e4m3 [M, K/2] lhs_packed, u32 [M, (K / META_K) * 2] lhs_meta, f8_e5m2 [N, K] rhs) {
  f32 [M, N] output{0.0f};
  int TILE_M = 64, TILE_N = 64, TILE_K = 64;
  int WARP_M = 16, WARP_N = 8, WARP_K = 64;
  parallel {block_m, block_n} by [cdiv(M, TILE_M), cdiv(N, TILE_N)] : block {
    parallel {iv_warp_m, iv_warp_n} by [cdiv(TILE_M, WARP_M), cdiv(TILE_N, WARP_N)] : group {
      mc = mma.fill.f32 0.0f;
      foreach {iv_k} in [cdiv(K, TILE_K)] {
        lhs_load_s = dma.copy lhs_packed.chunkat(block_m, iv_k) => shared;
        rhs_load_s = dma.copy rhs.chunkat(block_n, iv_k) => shared;
        lhs_load_s_mdata = dma.copy lhs_meta.chunkat(block_m, iv_k) => local;
        foreach iv_warp_k in [cdiv(TILE_K, WARP_K)] {
          ma = mma.load lhs_load_s.chunkat(iv_warp_m, iv_warp_k);
          mb = mma.load rhs_load_s.chunkat(iv_warp_n, iv_warp_k);
          me = mma.load lhs_load_s_mdata.chunkat(iv_warp_m, iv_warp_k);
          mma.row.row.sp mc, ma, mb, me;
        }
      }
      mma.store mc, output.chunkat(block_m#iv_warp_m, block_n#iv_warp_n);
    }
  }
  return output;
}

// mixed A:e5m2, B:e4m3
__co__ auto matmul_sp_k64_e5m2_e4m3(f8_e5m2 [M, K/2] lhs_packed, u32 [M, (K / META_K) * 2] lhs_meta, f8_e4m3 [N, K] rhs) {
  f32 [M, N] output{0.0f};
  int TILE_M = 64, TILE_N = 64, TILE_K = 64;
  int WARP_M = 16, WARP_N = 8, WARP_K = 64;
  parallel {block_m, block_n} by [cdiv(M, TILE_M), cdiv(N, TILE_N)] : block {
    parallel {iv_warp_m, iv_warp_n} by [cdiv(TILE_M, WARP_M), cdiv(TILE_N, WARP_N)] : group {
      mc = mma.fill.f32 0.0f;
      foreach {iv_k} in [cdiv(K, TILE_K)] {
        lhs_load_s = dma.copy lhs_packed.chunkat(block_m, iv_k) => shared;
        rhs_load_s = dma.copy rhs.chunkat(block_n, iv_k) => shared;
        lhs_load_s_mdata = dma.copy lhs_meta.chunkat(block_m, iv_k) => local;
        foreach iv_warp_k in [cdiv(TILE_K, WARP_K)] {
          ma = mma.load lhs_load_s.chunkat(iv_warp_m, iv_warp_k);
          mb = mma.load rhs_load_s.chunkat(iv_warp_n, iv_warp_k);
          me = mma.load lhs_load_s_mdata.chunkat(iv_warp_m, iv_warp_k);
          mma.row.row.sp mc, ma, mb, me;
        }
      }
      mma.store mc, output.chunkat(block_m#iv_warp_m, block_n#iv_warp_n);
    }
  }
  return output;
}

// small helper for dependent-false static_assert in templates
template <typename> struct dependent_false : std::false_type {};

// Templated FP8 K64 test runner (supports A/B combinations and preserves
// initialization semantics used by existing single-format tests).
template <typename A_t, typename B_t>
int run_case_k64_fp8(const char* tag, bool lhs_ones = false, bool lhs_random_pos = false, int pos0 = 0, int pos1 = 1) {
  std::mt19937 gen(42);
  auto lhs_dense = choreo::make_spandata<A_t>(M, K);
  auto rhs = choreo::make_spandata<B_t>(N, K);

  if (lhs_ones) {
    SparsePolicy<A_t>::init_structured_sparse_A_ones(lhs_dense, gen, lhs_random_pos, pos0, pos1);
  } else {
    SparsePolicy<A_t>::init_structured_sparse_A(lhs_dense, gen);
  }

  rhs.fill_random(-1.0f, 1.0f);

  auto lhs_packed = choreo::make_spandata<A_t>(M, K / 2);
  auto lhs_meta = choreo::make_spandata<choreo::u32>(M, (K / META_K) * 2);
  SparsePolicy<A_t>::encode(lhs_dense, lhs_packed, lhs_meta);

  if constexpr (std::is_same<A_t, choreo::f8_e4m3>::value && std::is_same<B_t, choreo::f8_e4m3>::value) {
    auto res = matmul_sp_k64_e4m3(lhs_packed.view(), lhs_meta.view(), rhs.view());

    float tolerance = 0.5f; // Adjusted for FP8 precision
    int errors = 0;
    int printed = 0;
    for (size_t i = 0; i < M; ++i)
      for (size_t j = 0; j < N; ++j) {
        float ref = 0.0f;
        for (size_t k = 0; k < K; ++k)
          ref += choreo::to_f32(lhs_dense[i][k]) * choreo::to_f32(rhs[j][k]);
        float got = res[i][j];
        if (std::abs(got - ref) >= tolerance) {
          errors++;
          if (printed < 5) {
            std::cout << "[" << tag << "] mismatch (" << i << "," << j
                      << ") ref=" << ref << " got=" << got << "\n";
            printed++;
          }
        }
      }
    std::cout << tag << ": " << errors << " errors\n";
    return errors;
  } else if constexpr (std::is_same<A_t, choreo::f8_e5m2>::value && std::is_same<B_t, choreo::f8_e5m2>::value) {
    auto res = matmul_sp_k64_e5m2(lhs_packed.view(), lhs_meta.view(), rhs.view());

    float tolerance = 0.5f; // Adjusted for FP8 precision
    int errors = 0;
    int printed = 0;
    for (size_t i = 0; i < M; ++i)
      for (size_t j = 0; j < N; ++j) {
        float ref = 0.0f;
        for (size_t k = 0; k < K; ++k)
          ref += choreo::to_f32(lhs_dense[i][k]) * choreo::to_f32(rhs[j][k]);
        float got = res[i][j];
        if (std::abs(got - ref) >= tolerance) {
          errors++;
          if (printed < 5) {
            std::cout << "[" << tag << "] mismatch (" << i << "," << j
                      << ") ref=" << ref << " got=" << got << "\n";
            printed++;
          }
        }
      }
    std::cout << tag << ": " << errors << " errors\n";
    return errors;
  } else if constexpr (std::is_same<A_t, choreo::f8_e4m3>::value && std::is_same<B_t, choreo::f8_e5m2>::value) {
    auto res = matmul_sp_k64_e4m3_e5m2(lhs_packed.view(), lhs_meta.view(), rhs.view());

    float tolerance = 0.5f; // Adjusted for FP8 precision
    int errors = 0;
    int printed = 0;
    for (size_t i = 0; i < M; ++i)
      for (size_t j = 0; j < N; ++j) {
        float ref = 0.0f;
        for (size_t k = 0; k < K; ++k)
          ref += choreo::to_f32(lhs_dense[i][k]) * choreo::to_f32(rhs[j][k]);
        float got = res[i][j];
        if (std::abs(got - ref) >= tolerance) {
          errors++;
          if (printed < 5) {
            std::cout << "[" << tag << "] mismatch (" << i << "," << j
                      << ") ref=" << ref << " got=" << got << "\n";
            printed++;
          }
        }
      }
    std::cout << tag << ": " << errors << " errors\n";
    return errors;
  } else if constexpr (std::is_same<A_t, choreo::f8_e5m2>::value && std::is_same<B_t, choreo::f8_e4m3>::value) {
    auto res = matmul_sp_k64_e5m2_e4m3(lhs_packed.view(), lhs_meta.view(), rhs.view());

    float tolerance = 0.5f; // Adjusted for FP8 precision
    int errors = 0;
    int printed = 0;
    for (size_t i = 0; i < M; ++i)
      for (size_t j = 0; j < N; ++j) {
        float ref = 0.0f;
        for (size_t k = 0; k < K; ++k)
          ref += choreo::to_f32(lhs_dense[i][k]) * choreo::to_f32(rhs[j][k]);
        float got = res[i][j];
        if (std::abs(got - ref) >= tolerance) {
          errors++;
          if (printed < 5) {
            std::cout << "[" << tag << "] mismatch (" << i << "," << j
                      << ") ref=" << ref << " got=" << got << "\n";
            printed++;
          }
        }
      }
    std::cout << tag << ": " << errors << " errors\n";
    return errors;
  } else {
    static_assert(dependent_false<A_t>::value, "unsupported FP8 combo");
  }
}

int run_case_k64_e4m3(const char* tag) {
  std::mt19937 gen(42);
  auto lhs_dense = choreo::make_spandata<choreo::f8_e4m3>(M, K);
  auto rhs = choreo::make_spandata<choreo::f8_e4m3>(N, K);

  // random init
  SparsePolicy<choreo::f8_e4m3>::init_structured_sparse_A(lhs_dense, gen);
  rhs.fill_random(-1.0f, 1.0f);

  // DEBUG: row-wise assign A: nonzeros in each row share the same value (row index + 1)
  // for (size_t i = 0; i < M; ++i) {
  //   for (size_t k = 0; k < K; ++k) {
  //     float v = static_cast<float>(i + 1);
  //     if (choreo::to_f32(lhs_dense[i][k]) != 0.0f)
  //       lhs_dense[i][k] = choreo::utils::from_f32<choreo::f8_e4m3>(v);
  //   }
  // }

  // DEBUG: set rhs so each row j has the same value (j+1.0), increasing by row
  // for (size_t j = 0; j < N; ++j) {
  //   for (size_t k = 0; k < K; ++k) {
  //     float v = static_cast<float>(k + 1);
  //     rhs[j][k] = choreo::utils::from_f32<choreo::f8_e4m3>(v);
  //   }
  // }

  // DEBUG: rhs all ones
  // for (size_t j = 0; j < N; ++j)
  //   for (size_t k = 0; k < K; ++k)
  //     rhs[j][k] = choreo::utils::from_f32<choreo::f8_e4m3>(1.0f);

  auto lhs_packed = choreo::make_spandata<choreo::f8_e4m3>(M, K / 2);
  auto lhs_meta = choreo::make_spandata<choreo::u32>(M, (K / META_K) * 2);
  SparsePolicy<choreo::f8_e4m3>::encode(lhs_dense, lhs_packed, lhs_meta);

  auto res = matmul_sp_k64_e4m3(lhs_packed.view(), lhs_meta.view(), rhs.view());

  float tolerance = 0.5f; // Adjusted for FP8 precision
  int errors = 0;
  int printed = 0;
  for (size_t i = 0; i < M; ++i)
    for (size_t j = 0; j < N; ++j) {
      float ref = 0.0f;
      for (size_t k = 0; k < K; ++k)
        ref += choreo::to_f32(lhs_dense[i][k]) * choreo::to_f32(rhs[j][k]);
      float got = res[i][j];
      if (std::abs(got - ref) >= tolerance) {
        errors++;
        if (printed < 5) {
          std::cout << "[" << tag << "] mismatch (" << i << "," << j
                    << ") ref=" << ref << " got=" << got << "\n";
          printed++;
        }
      }
    }
  std::cout << tag << ": " << errors << " errors\n";
  return errors;
}

int main() {
  int errors = 0;
  errors += run_case_k64_fp8<choreo::f8_e4m3, choreo::f8_e4m3>("k64_e4m3");
  errors += run_case_k64_fp8<choreo::f8_e5m2, choreo::f8_e5m2>("k64_e5m2", true, true, 0, 1);
  errors += run_case_k64_fp8<choreo::f8_e4m3, choreo::f8_e5m2>("k64_e4m3_e5m2");
  errors += run_case_k64_fp8<choreo::f8_e5m2, choreo::f8_e4m3>("k64_e5m2_e4m3", true, true, 0, 1);
  if (errors == 0) {
    std::cout << "Test Passed\n";
    return 0;
  }
  std::cout << "FAILED: " << errors << " errors\n";
  return 1;
}

// CHECK: Test Passed
