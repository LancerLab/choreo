// REQUIRES: TARGET-SM_90A
// RUN: choreo -gs -t cute -arch=sm_90a %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

#define M 128
#define N 256
#define K 128

__co__ auto matmul(f8_e4m3 [M, K] lhs, f8_e4m3 [K, N] rhs) {
  f32 [M, N] output;

  int MMA_M = 16, MMA_N = 8, MMA_K = 32;
  parallel {m, n} by [M / MMA_M / 2, N / MMA_N / 2 ] : block {
    mc = mma.fill.f32 0.0f;
    parallel {g0, g1} by [2, 2]: group {
      foreach k in K / MMA_K {
        ma = mma.load lhs.chunkat(m#g0, k);
        mb = mma.load rhs.chunkat(k, n#g1);
        mma.row.col mc, ma, mb;
      }
      mma.store mc, output.chunkat(m#g0, n#g1);
    };
  }
  return output;
}

int main() {
  auto lhs = choreo::make_spandata<choreo::f8_e4m3>(M, K);
  auto rhs = choreo::make_spandata<choreo::f8_e4m3>(K, N);
#if 0
  for (size_t i = 0; i < lhs.shape()[0]; ++i)
    for (size_t j = 0; j < lhs.shape()[1]; ++j) {
      lhs[i][j] = f8_e4m3(i*0.02f+j*0.1f);
    }
  for (size_t i = 0; i < rhs.shape()[0]; ++i)
    for (size_t j = 0; j < rhs.shape()[1]; ++j) {
      rhs[i][j] = f8_e4m3(i*0.07f+j*0.03f);
    }
#else
  lhs.fill_random(0.0f, 1.0f);
  rhs.fill_random(0.0f, 1.0f);
#endif

  auto res = matmul(lhs.view(), rhs.view());

  float tolerance = 0.002f;
  // verfication
  for (size_t i = 0; i < res.shape()[0]; ++i)
    for (size_t j = 0; j < res.shape()[1]; ++j) {
      auto ref = 0.0f;
      for (size_t k = 0; k < lhs.shape()[1]; ++k)
        ref += float(lhs[i][k]) * float(rhs[k][j]);
      auto delta = std::abs((ref - float(res[i][j])) / ref);
      if (delta >= tolerance) {
        std::cout << "[" << i << ", " << j << "] " << ref << " <-> " << float(res[i][j]) << ", delta: " << delta * 100 << "%\n";
      }
      choreo::choreo_assert((delta < tolerance), "values are not equal.");
    }

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed
