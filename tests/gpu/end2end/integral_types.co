// REQUIRES: TARGET-GPU
// RUN: choreo -gs -t cute %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

__co__ auto ele_add_s32(s32 [6, 64] lhs, s32 [6, 64] rhs) {
  s32[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}
__co__ auto ele_add_u32(u32 [6, 64] lhs, u32 [6, 64] rhs) {
  u32[lhs.span] output;
  parallel p by 6, q by 64
  output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}
__co__ auto ele_add_s16(s16 [6, 64] lhs, s16 [6, 64] rhs) {
  s16[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}
__co__ auto ele_add_u16(u16 [6, 64] lhs, u16 [6, 64] rhs) {
  u16[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}
__co__ auto ele_add_s8(s8 [6, 64] lhs, s8 [6, 64] rhs) {
  s8[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}
__co__ auto ele_add_u8(u8 [6, 64] lhs, u8 [6, 64] rhs) {
  u8[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}

__co__ auto ele_add_u6(u6 [6, 64] lhs, u6 [6, 64] rhs) {
  u6[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}

__co__ auto ele_add_s6(s6 [6, 64] lhs, s6 [6, 64] rhs) {
  s6[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}

__co__ auto ele_add_u4(u4 [6, 64] lhs, u4 [6, 64] rhs) {
  u4[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}

__co__ auto ele_add_s4(s4 [6, 64] lhs, s4 [6, 64] rhs) {
  s4[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}

__co__ auto copy_u2(u2 [6, 64] lhs) {
  u2[lhs.span] output;
  parallel p by 6, q by 64
  output.at(p, q) = lhs.at(p, q);
  return output;
}
__co__ auto copy_s2(s2 [6, 64] lhs) {
  s2[lhs.span] output;
  parallel p by 6, q by 64
  output.at(p, q) = lhs.at(p, q);
  return output;
}

__co__ auto copy_u1(u1 [6, 64] lhs) {
  u1[lhs.span] output;
  parallel p by 6, q by 64
  output.at(p, q) = lhs.at(p, q);
  return output;
}
__co__ auto copy_bin1(bin1 [6, 64] lhs) {
  bin1[lhs.span] output;
  parallel p by 6, q by 64
  output.at(p, q) = lhs.at(p, q);
  return output;
}


#define TEST_CUTE_TYPE1(type) \
  using t_##type = choreo::type; \
  auto a_##type = choreo::make_spandata<t_##type>(6, 64); \
  auto b_##type = choreo::make_spandata<t_##type>(6, 64); \
  a_##type.fill_random(0, 10); \
  b_##type.fill_random(0, 10); \
  auto res_##type = ele_add_##type(a_##type.view(), b_##type.view()); \
  for (size_t i = 0; i < res_##type.shape()[0]; ++i) \
    for (size_t j = 0; j < res_##type.shape()[1]; ++j) { \
      t_##type ref = static_cast<t_##type>(a_##type[i][j] + b_##type[i][j]); \
      t_##type res_val = res_##type[i][j]; \
      if (res_val != ref) choreo::choreo_assert(false, "values are not equal."); \
    } \
  std::cout << "Test " << #type << " Passed\n" << std::endl;

#define TEST_CUTE_TYPE2(type) \
  using t_##type = choreo::type; \
  auto a_##type = choreo::make_spandata<t_##type>(6, 64); \
  auto b_##type = choreo::make_spandata<t_##type>(6, 64); \
  a_##type.fill_random(0, 1); \
  b_##type.fill_random(0, 1); \
  auto res_##type = ele_add_##type(a_##type.view(), b_##type.view()); \
  for (size_t i = 0; i < res_##type.shape()[0]; ++i) \
    for (size_t j = 0; j < res_##type.shape()[1]; ++j) { \
      t_##type ref = static_cast<t_##type>(a_##type[i][j] + b_##type[i][j]); \
      t_##type res_val = res_##type[i][j]; \
      if (res_val != ref) choreo::choreo_assert(false, "values are not equal."); \
    } \
  std::cout << "Test " << #type << " Passed\n" << std::endl;

#define TEST_CUTE_TYPE3(type) \
  using t_##type = choreo::type; \
  auto a_##type = choreo::make_spandata<t_##type>(6, 64); \
  auto res_##type = copy_##type(a_##type.view()); \
  for (size_t i = 0; i < res_##type.shape()[0]; ++i) \
    for (size_t j = 0; j < res_##type.shape()[1]; ++j) { \
      t_##type ref = static_cast<t_##type>(a_##type[i][j]); \
      t_##type res_val = res_##type[i][j]; \
      if (res_val != ref) choreo::choreo_assert(false, "values are not equal."); \
    } \
  std::cout << "Test " << #type << " Passed\n" << std::endl;

int main() { /// host program
  TEST_CUTE_TYPE1(s32);
  TEST_CUTE_TYPE1(u32);
  TEST_CUTE_TYPE1(s16);
  TEST_CUTE_TYPE1(u16);
  TEST_CUTE_TYPE1(s8);
  TEST_CUTE_TYPE1(u8);
  TEST_CUTE_TYPE2(s6);
  TEST_CUTE_TYPE2(u6);
  TEST_CUTE_TYPE2(s4);
  TEST_CUTE_TYPE2(u4);
  TEST_CUTE_TYPE3(s2);
  TEST_CUTE_TYPE3(u2);
  TEST_CUTE_TYPE3(bin1);
  TEST_CUTE_TYPE3(u1);
  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test s32 Passed
// CHECK: Test u32 Passed
// CHECK: Test s16 Passed
// CHECK: Test u16 Passed
// CHECK: Test s8 Passed
// CHECK: Test u8 Passed
// CHECK: Test s6 Passed
// CHECK: Test u6 Passed
// CHECK: Test s4 Passed
// CHECK: Test u4 Passed
// CHECK: Test s2 Passed
// CHECK: Test u2 Passed
// CHECK: Test bin1 Passed
// CHECK: Test u1 Passed
// CHECK: Test Passed