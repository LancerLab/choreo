// REQUIRES: TARGET-SM_90
// RUN: choreo -gs -t cute -arch=sm_90a %s -o %s.cute.result && CUDA_VISIBLE_DEVICES=1 CHOREO_DISABLE_TIMING=1 bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

__co__ void matmul(global f16 [M, K] lhs, global f16 [N, K] rhs, global f16 [M, N] output) {

  int WARP_M = 64, WARP_N = 64, TILE_K = 64, WARP_K = 16;

  // each block handles 64x64 block with WGMMA
  // WGMMA requires 128 threads (4 warps x 32 threads/warp)
  parallel {block_m, block_n} by [cdiv(M, WARP_M), cdiv(N, WARP_N)] : block {
    shared f16 [WARP_M, TILE_K] lhs_load_s;
    shared f16 [WARP_N, TILE_K] rhs_load_s;
    mc = mma.fill.f32 0.0f;
    foreach {iv_k} in [cdiv(K, TILE_K)] {
      tma.copy.swiz<128> lhs.subspan(WARP_M, TILE_K).at(block_m, iv_k) => lhs_load_s;
      tma.copy.swiz<128> rhs.chunkat(block_n, iv_k) => rhs_load_s;

      // WGMMA requires 128 threads: 4 warps x 32 threads/warp
      foreach {iv_warp} in [cdiv(TILE_K, WARP_K)] {
        parallel p by 1 : group-4 {
          ma = mma.load.swiz<128> lhs_load_s.chunkat(_, iv_warp);
          mb = mma.load.swiz<128> rhs_load_s.chunkat(_, iv_warp);
          mma.row.row mc, ma, mb;   // row * col : c += a * b;
        }
      }
    }

    shared f16 [WARP_M, WARP_N] output_s;
    mma.store mc, output_s;

    // tma.copy output_s => output.subspan(M0, WARP_N).at(block_m, block_n);
    tma.copy output_s => output.subspan(WARP_M, WARP_N).at(block_m, block_n);
  }
}

// int matmul(const bf16 *a_d, const bf16 *b_d, bf16 *c_d, int M, int K, int N) {
// int main(int argc, char **argv) {
int main(int argc, char** argv) {
  bool enable_timing = true;
  auto is_disable_timing_arg = [](const char* s) {
    const char* t = "--disable-timing";
    int i = 0;
    while (t[i] != '\0' && s[i] == t[i]) ++i;
    return t[i] == '\0' && s[i] == '\0';
  };
  for (int i = 1; i < argc; ++i) {
    if (is_disable_timing_arg(argv[i])) {
      enable_timing = false;
      break;
    }
  }

  const char* timing_env = std::getenv("CHOREO_DISABLE_TIMING");
  if (timing_env && timing_env[0] == '1' && timing_env[1] == '\0') {
    enable_timing = false;
  }
  
  size_t M = 768;
  size_t N = 512;
  size_t K = 512;

  auto lhs_h = choreo::make_spandata<choreo::f16>(M, K);
  auto rhs_h = choreo::make_spandata<choreo::f16>(N, K);
  auto res_h = choreo::make_spandata<choreo::f16>(M, N);
  lhs_h.fill_random(0, 2);
  rhs_h.fill_random(0, 2);
  res_h.fill(0.0f);

  half *a_d = nullptr, *b_d = nullptr, *c_d = nullptr;
  cudaMalloc(&a_d, M * K * sizeof(half));
  cudaMalloc(&b_d, N * K * sizeof(half));
  cudaMalloc(&c_d, M * N * sizeof(half));
  
  cudaMemcpy(a_d, lhs_h.data(), M * K * sizeof(half), cudaMemcpyHostToDevice);
  cudaMemcpy(b_d, rhs_h.data(), N * K * sizeof(half), cudaMemcpyHostToDevice);
  cudaMemcpy(c_d, res_h.data(), M * N * sizeof(half), cudaMemcpyHostToDevice);
  cudaDeviceSynchronize();

  auto lhs_d = choreo::make_spanview<choreo::f16, 2>(a_d, {M, K});
  auto rhs_d = choreo::make_spanview<choreo::f16, 2>(b_d, {N, K});
  auto res_d = choreo::make_spanview<choreo::f16, 2>(c_d, {M, N});
  if (enable_timing) {
    choreo::TimerOption topt;
    topt.warmup = 10;
    topt.repeat = 50;
    auto avg_ms = choreo::timing([&]() { matmul(lhs_d, rhs_d, res_d); cudaDeviceSynchronize(); }, topt);
    std::cout << "Timing avg ms: " << avg_ms << "\n";
  } else {
    matmul(lhs_d, rhs_d, res_d);
  }

  cudaMemcpy(res_h.data(), c_d, M * N * sizeof(half), cudaMemcpyDeviceToHost);
  cudaDeviceSynchronize();

  auto lhs_view = lhs_h.view();
  auto rhs_view = rhs_h.view();
  auto res_view = res_h.view();

  float tolerance = 0.005f;
  // verfication
  for (size_t i = 0; i < M; ++i) {
    for (size_t j = 0; j < N; ++j) {
      auto ref = 0.0f;
      for (size_t k = 0; k < lhs_view.shape()[1]; ++k)
        ref += __half2float(lhs_view[i][k] * rhs_view[j][k]);
      auto delta = std::abs((ref - __half2float(res_view[i][j])) / ref);
      if (delta >= tolerance) {
        std::cout << "[" << i << ", " << j << "] " << ref << " <-> " << __half2float(res_h[i][j]) << ", delta: " << delta * 100 << "%\n";
      }
      choreo::choreo_assert((delta < tolerance), "values are not equal.");
    }
  }

  std::cout << "Test Passed\n" << std::endl;
}
// CHECK: Test Passed
