// REQUIRES: TARGET-GPU
// RUN: choreo -gs -t cute -use-cuda-type=false %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result
// RUN: choreo -gs -t cute -use-cuda-type=true %s -o %s.cute.result && bash %s.cute.result --execute | FileCheck --match-full-lines %s && rm -f %s.cute.result

__co__ auto ele_add_f32(f32 [6, 64] lhs, f32 [6, 64] rhs) {
  f32[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}
__co__ auto ele_add_f16(f16 [6, 64] lhs, f16 [6, 64] rhs) {
  f16[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}
__co__ auto ele_add_bf16(bf16 [6, 64] lhs, bf16 [6, 64] rhs) {
  bf16[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q) + rhs.at(p, q);
  return output;
}
__co__ auto copy_f8_e4m3(f8_e4m3 [6, 64] lhs) {
  f8_e4m3[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q);
  return output;
}
__co__ auto copy_f8_e5m2(f8_e5m2 [6, 64] lhs) {
  f8_e5m2[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q);
  return output;
}
#if 0
__co__ auto copy_f6_e3m2(f6_e3m2 [6, 64] lhs) {
  f6_e3m2[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q);
  return output;
}

__co__ auto copy_f6_e2m3(f6_e2m3 [6, 64] lhs) {
  f6_e2m3[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q);
  return output;
}

__co__ auto copy_f4_e2m1(f4_e2m1 [6, 64] lhs) {
  f4_e2m1[lhs.span] output;
  parallel p by 6, q by 64
    output.at(p, q) = lhs.at(p, q);
  return output;
}
#endif

#define TEST_CUTE_TYPE(type) \
  using t_##type = choreo::type; \
  auto a_##type = choreo::make_spandata<t_##type>(6, 64); \
  auto b_##type = choreo::make_spandata<t_##type>(6, 64); \
  a_##type.fill_random(-10.0f, 10.0f); \
  b_##type.fill_random(-10.0f, 10.0f); \
  auto res_##type = ele_add_##type(a_##type.view(), b_##type.view()); \
  for (size_t i = 0; i < res_##type.shape()[0]; ++i) \
    for (size_t j = 0; j < res_##type.shape()[1]; ++j) { \
      auto ref = float(a_##type[i][j]) + float(b_##type[i][j]); \
      if (std::abs(float(res_##type[i][j]) - ref) > 0.1f) \
        choreo::choreo_assert(a_##type[i][j] + b_##type[i][j] == res_##type[i][j], "values are not equal."); \
    } \
  std::cout << "Test " << #type << " Passed\n" << std::endl;

#define TEST_CUTE_TYPE2(type) \
  using t_##type = choreo::type; \
  auto a_##type = choreo::make_spandata<t_##type>(6, 64); \
  a_##type.fill_random(-10.0f, 10.0f); \
  auto res_##type = copy_##type(a_##type.view()); \
  for (size_t i = 0; i < res_##type.shape()[0]; ++i) \
    for (size_t j = 0; j < res_##type.shape()[1]; ++j) { \
      auto ref = float(a_##type[i][j]); \
      if (float(res_##type[i][j]) != ref) \
        choreo::choreo_assert(false, "values are not equal."); \
    } \
  std::cout << "Test " << #type << " Passed\n" << std::endl;

int main() { /// host program
  TEST_CUTE_TYPE(f32);
  TEST_CUTE_TYPE(f16);
  TEST_CUTE_TYPE(bf16);

  TEST_CUTE_TYPE2(f8_e4m3);
  TEST_CUTE_TYPE2(f8_e5m2);
  // TEST_CUTE_TYPE2(f6_e3m2);
  // TEST_CUTE_TYPE2(f6_e2m3);
  // TEST_CUTE_TYPE2(f4_e2m1);
  std::cout << "Test Passed\n" << std::endl;
}
// CHECK: Test f32 Passed
// CHECK: Test f16 Passed
// CHECK: Test bf16 Passed
// CHECK: Test f8_e4m3 Passed
// CHECK: Test f8_e5m2 Passed
// CHECK1: Test f6_e3m2 Passed
// CHECK1: Test f6_e2m3 Passed
// CHECK1: Test f4_e2m1 Passed
// CHECK: Test Passed
