// RUN: choreo %s -i 2>&1 | FileCheck %s

/// device program
__co__ auto matmul(s32 [M, K] lhs, s32 [K, N] rhs) {
  s32[lhs.span(0), rhs.span(1)] output;

  block_shape = {8, 1024, 128};
  parallel p by 1 {
    with index = {m_tile, k_tile, n_tile} in [M, K, N] / block_shape {
      foreach m_tile {
        foreach n_tile {
          local s32 [block_shape(0), block_shape(1)] local_out;
          foreach k_tile {
            lhs_load = dma.copy lhs.chunkat(m_tile, k_tile) => local;
            rhs_load = dma.copy rhs.chunkat(k_tile, n_tile) => local;

            call kernel(lhs_load.data, rhs_load.data, local_out, block_shape(0), block_shape(1), block_shape(2));

            dma.copy local_out => output.chunkat(m_tile, n_tile); // can use defined vars
          }
        }
      }
    }
  }
  return output;
}

// CHECK: Parameter: ::matmul::lhs, Type: s32 mdspan<2> [::matmul::M, ::matmul::K]
// CHECK: Parameter: ::matmul::rhs, Type: s32 mdspan<2> [::matmul::K, ::matmul::N]
// CHECK: Symbol:    ::matmul::output, Type: global s32 mdspan<2> [::matmul::M, ::matmul::N]
// CHECK: Symbol:    ::matmul::block_shape, Type: ituple<3>
// CHECK: Bounded:   ::matmul{{(::paraby_[0-9]+)*}}::p, Type: {int}->[1]
// CHECK: Bounded:   ::matmul{{(::paraby_[0-9]+)*}}::within_0::index, Type: {int,int,int}->[(::matmul::M / 8), (::matmul::K / 1024), (::matmul::N / 128)]
// CHECK: Bounded:   ::matmul{{(::paraby_[0-9]+)*}}::within_0::m_tile, Type: {int}->[(::matmul::M / 8)]
// CHECK: Bounded:   ::matmul{{(::paraby_[0-9]+)*}}::within_0::k_tile, Type: {int}->[(::matmul::K / 1024)]
// CHECK: Bounded:   ::matmul{{(::paraby_[0-9]+)*}}::within_0::n_tile, Type: {int}->[(::matmul::N / 128)]
// CHECK: Symbol:    ::matmul{{(::paraby_[0-9]+)*}}::within_0::foreach_0::foreach_1::local_out, Type: local s32 mdspan<2> [8, 1024]
// CHECK: Future:    ::matmul{{(::paraby_[0-9]+)*}}::within_0::foreach_0::foreach_1::foreach_2::lhs_load, Type: sync=>local s32 mdspan<2> [8, 1024]
// CHECK: Future:    ::matmul{{(::paraby_[0-9]+)*}}::within_0::foreach_0::foreach_1::foreach_2::rhs_load, Type: sync=>local s32 mdspan<2> [1024, 128]
// CHECK: Future:    ::matmul{{(::paraby_[0-9]+)*}}::within_0::foreach_0::foreach_1::foreach_2::(anon), Type: sync=>global s32 mdspan<2> [8, 128]
// CHECK: Function:  ::matmul, Type: s32 mdspan<2> [::matmul::M, ::matmul::N] (*)(s32 mdspan<2> [::matmul::M, ::matmul::K], s32 mdspan<2> [::matmul::K, ::matmul::N])
