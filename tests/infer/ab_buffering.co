// RUN: choreo -i %s | FileCheck --match-full-lines %s

__co__ auto ab_buffer(s32 [6, 17, 128] lhs, s32 [6, 17, 128] rhs) { /// device program
  s32 [lhs.span] output;

  parallel p by 6 {
    with index = {x, y} in [17, 4] {
      local s32 [lhs.span / {#p, #x, #y}] lbufA, lbufB; 
      local s32 [rhs.span / {#p, #x, #y}] rbufA, rbufB; 
      local s32 [rhs.span / {#p, #x, #y}] l_out; 

      // first bunch
      lfA = dma.copy.async lhs.chunkat(p, index) => lbufA;
      rfA = dma.copy.async rhs.chunkat(p, index) => rbufA;

      // dummy DMA used for A-B buffering
      lfB = dma.any;
      rfB = dma.any;
      of = dma.any;

      foreach x, y(1:-1) {
        lfB = dma.copy.async lhs.chunkat(p, x, y) => select(y % 2, lbufA, lbufB);
        rfB = dma.copy.async rhs.chunkat(p, x, y) => select(y % 2, rbufA, rbufB);
        wait lfB, rfB, of;

        call kernel(lfB.data, rfB.data, l_out, |lfB.span|);

        of = dma.copy.async l_out => output.chunkat(p, x, y); // can use defined vars

        swap(lfA, lfB);
        swap(rfA, rfB);
      }

      wait of;
      call kernel(lfB.data, rfB.data, l_out, |lfB.span|);
      dma.copy l_out => output.chunkat(p, x, y);
    }
  }

  return output;
}

// CHECK: Parameter: ::ab_buffer::lhs, Type: s32 mdspan<3> [6, 17, 128]
// CHECK: Parameter: ::ab_buffer::rhs, Type: s32 mdspan<3> [6, 17, 128]
// CHECK: Symbol:    ::ab_buffer::output, Type: global s32 mdspan<3> [6, 17, 128]
// CHECK: Bounded:   ::ab_buffer{{(::paraby_[0-9]+)*}}::p, Type: {int}->[6]
// CHECK: Bounded:   ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::index, Type: {int,int}->[17, 4]
// CHECK: Bounded:   ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::x, Type: {int}->[17]
// CHECK: Bounded:   ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::y, Type: {int}->[4]
// CHECK: Symbol:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::lbufA, Type: local s32 mdspan<3> [1, 1, 32]
// CHECK: Symbol:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::lbufB, Type: local s32 mdspan<3> [1, 1, 32]
// CHECK: Symbol:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::rbufA, Type: local s32 mdspan<3> [1, 1, 32]
// CHECK: Symbol:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::rbufB, Type: local s32 mdspan<3> [1, 1, 32]
// CHECK: Symbol:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::l_out, Type: local s32 mdspan<3> [1, 1, 32]
// CHECK: Future:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::lfA, Type: async=>local s32 mdspan<3> [1, 1, 32]
// CHECK: Future:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::rfA, Type: async=>local s32 mdspan<3> [1, 1, 32]
// CHECK: Future:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::lfB, Type: async=>local s32 mdspan<3> [1, 1, 32]
// CHECK: Future:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::rfB, Type: async=>local s32 mdspan<3> [1, 1, 32]
// CHECK: Future:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::of, Type: async=>global s32 mdspan<3> [1, 1, 32]
// CHECK: Future:    ::ab_buffer{{(::paraby_[0-9]+)*}}::within_0::(anon), Type: sync=>global s32 mdspan<3> [1, 1, 32]
// CHECK: Function:  ::ab_buffer, Type: s32 mdspan<3> [6, 17, 128] (*)(s32 mdspan<3> [6, 17, 128], s32 mdspan<3> [6, 17, 128])
