// RUN: choreo -e %s | FileCheck %s --match-full-lines

__co__ int with_foreach(int b, f32 [36, 27, 128] input) {
  ndims: [3, b];
  int sum = 0;
  parallel p by 6 {        // 'p' is bounded to [0, 6)
    with index in ndims {  // index is bounded to
      // foreach to create two-level loop nests, be like:
      //
      // for ( index_0 = 0; index_0 < 6; index_0++ )
      //   for ( index_1 = 0; index_1 < 6; index_1++ )
      foreach index {
        // shape of each chunk:
        //    [36 / #p, 27 / #index.dim(0), 6 / #index.dim(1)]
        //  = [6, 9, 128 / b]
        f = dma.copy.async input.chunkat(p, index) => local;
        sum = sum + index(0);
        wait f;
        call cfunction(f.data);
      }
    }
    with idx in [6] {
      with {m} in [3] {
        foreach idx, m {
          f = dma.copy.async input.chunkat(p, idx, m) => local;
          sum = sum + index(0);
          wait f;
          call cfunction(f.data);
        }
      }
    }

    with {m} in [3] {
      foreach m(1:-1) {}
      foreach m(2:) {}
      foreach m(:-2) {}
      foreach m(:) {}
    }

    int bb = |input.span|;
    with idx0 in 3 {
      with idx1 in b {
        with idx2 in bb {
          foreach idx0, idx1, idx2 {}
        }
      }
    }
  }
}

// CHECK: ChoreoFunction
// CHECK:  `- Name: with_foreach
// CHECK:  `- Return type: s32
// CHECK:  `- Parameters:
// CHECK:    `-  type: s32, symbol: b
// CHECK:    `-  type: f32 [ 36 27 128  ], symbol: input
// CHECK:  `- Type Decl: ndims - [ 3 b ]
// CHECK:  `- Var Decl (s32): sum = 0
// CHECK:  `- Parallelization: index symbol: p, bound [0, 6)
// CHECK:   `- With Block:
// CHECK:     (within constraints)
// CHECK:     `- index in ndims
// CHECK:     (with statements)
// CHECK:     `- Foreach Block:
// CHECK:      `- Iteration variables: index
// CHECK:      `- DMA.copy.async
// CHECK:        `- future: f
// CHECK:        `- from: input.Chunk( (ubound p) , (ubound index) ).At(p, index)
// CHECK:        `- to: local
// CHECK:      `- Assign: sum =  (sum + index(0))
// CHECK:      `- WAIT: f
// CHECK:      `- Call: cfunction
// CHECK:        `- with arguments: (dataof f)
// CHECK:   `- With Block:
// CHECK:     (within constraints)
// CHECK:     `- idx in [ 6 ]
// CHECK:     (with statements)
// CHECK:     `- With Block:
// CHECK:       (within constraints)
// CHECK:       `-  {m} in [ 3 ]
// CHECK:       (with statements)
// CHECK:       `- Foreach Block:
// CHECK:        `- Iteration variables: idx
// CHECK:        `- Iteration variables: m
// CHECK:        `- DMA.copy.async
// CHECK:          `- future: f
// CHECK:          `- from: input.Chunk( (ubound p) , (ubound idx) , (ubound m) ).At(p, idx, m)
// CHECK:          `- to: local
// CHECK:        `- Assign: sum =  (sum + index(0))
// CHECK:        `- WAIT: f
// CHECK:        `- Call: cfunction
// CHECK:          `- with arguments:  (dataof f)
// CHECK:   `- With Block:
// CHECK:     (within constraints)
// CHECK:     `-  {m} in [ 3 ]
// CHECK:     (with statements)
// CHECK:     `- Foreach Block:
// CHECK:      `- Iteration variables: m
// CHECK:      `- Loop Control: (1:-1:1)
// CHECK:     `- Foreach Block:
// CHECK:      `- Iteration variables: m
// CHECK:      `- Loop Control: (2:?:1)
// CHECK:     `- Foreach Block:
// CHECK:      `- Iteration variables: m
// CHECK:      `- Loop Control: (?:-2:1)
// CHECK:     `- Foreach Block:
// CHECK:      `- Iteration variables: m
// CHECK:      `- Loop Control: (?:?:1)
// CHECK:   `- Var Decl (s32): bb =  (sizeof input.span)
// CHECK:   `- With Block:
// CHECK:     (within constraints)
// CHECK:     `- idx0 in 3
// CHECK:     (with statements)
// CHECK:     `- With Block:
// CHECK:       (within constraints)
// CHECK:       `- idx1 in b
// CHECK:       (with statements)
// CHECK:       `- With Block:
// CHECK:         (within constraints)
// CHECK:         `- idx2 in bb
// CHECK:         (with statements)
// CHECK:         `- Foreach Block:
// CHECK:          `- Iteration variables: idx0
// CHECK:          `- Iteration variables: idx1
// CHECK:          `- Iteration variables: idx2
