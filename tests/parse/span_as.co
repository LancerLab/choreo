// RUN: choreo -e %s | FileCheck --match-full-lines %s

__co__ auto span_as(s32 [32, 18, 9] a) {
  f32 [a.span] b;
  parallel p by 2 {
     dma.copy a.span_as([16, 9, 36]).chunkat(p, p, p) => local;
     dma.copy a.span_as([144, 36]).chunkat(p, p) => local;
     f = dma.copy b.span_as([8, 2, 18, 18]).chunkat(p, p, p, p) => local;
     // f.data: [4, 1, 9, 9]
     shared f32 [4, 9, 9] c;
     dma.copy f.span_as([4, 9, 9]) => c;
     dma.copy f.data.span_as([4, 9, 9]) => c;
  }
}

// CHECK: ChoreoFunction
// CHECK:  `- Name: span_as
// CHECK:  `- Return type: unknown
// CHECK:  `- Parameters:
// CHECK:    `-  type: s32 [ 32 18 9 ], symbol: a
// CHECK:  `- Var Decl (f32 [ a.span ], default): b
// CHECK:  `- Parallelization:  index symbol: p, bound [0, 2)
// CHECK:   `- DMA.copy
// CHECK:     `- from: a.SpanAs([ 16 9 36 ]).Chunk( (ubound p) , (ubound p) , (ubound p) ).At(p, p, p)
// CHECK:     `- to: local
// CHECK:   `- DMA.copy
// CHECK:     `- from: a.SpanAs([ 144 36 ]).Chunk( (ubound p) , (ubound p) ).At(p, p)
// CHECK:     `- to: local
// CHECK:   `- DMA.copy
// CHECK:     `- future: f
// CHECK:     `- from: b.SpanAs([ 8 2 18 18 ]).Chunk( (ubound p) , (ubound p) , (ubound p) , (ubound p) ).At(p, p, p, p)
// CHECK:     `- to: local
// CHECK:   `- Var Decl (f32 [ 4 9 9 ], shared): c
// CHECK:   `- DMA.copy
// CHECK:     `- from: f.SpanAs([ 4 9 9 ])
// CHECK:     `- to: c
// CHECK:   `- DMA.copy
// CHECK:     `- from: f.SpanAs([ 4 9 9 ])
// CHECK:     `- to: c
